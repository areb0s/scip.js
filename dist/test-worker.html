<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SCIP.js Worker Test (OpenCV-style)</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 800px;
      margin: 40px auto;
      padding: 20px;
      background: #1a1a2e;
      color: #e0e0e0;
    }
    h1 { color: #4fc3f7; }
    pre {
      background: #0d1117;
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      white-space: pre-wrap;
    }
    .success { color: #4caf50; }
    .error { color: #f44336; }
    button {
      background: #4fc3f7;
      color: #1a1a2e;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 5px 10px 0;
    }
    button:hover { background: #29b6f6; }
    #result { margin-top: 20px; }
    code { background: #0d1117; padding: 2px 6px; border-radius: 4px; }
  </style>
</head>
<body>
  <h1>SCIP.js Worker Test (OpenCV-style)</h1>
  <p>Testing CDN loading pattern like OpenCV in Worker</p>
  
  <button onclick="testInWorker()">Run Test in Worker</button>
  
  <div id="result">
    <pre>Click "Run Test in Worker" to test OpenCV-style loading pattern</pre>
  </div>

  <h2>Worker Code Pattern:</h2>
  <pre>
// Set base URL before loading
self.SCIP_BASE_URL = 'https://cdn.../dist/';

// Fetch and execute script
const response = await fetch(self.SCIP_BASE_URL + 'scip.min.js');
new Function(await response.text())();

// Wait for initialization (like OpenCV's cv.ready)
await self.SCIP.ready;

// Use SCIP
const result = await self.SCIP.solve(`...`);
  </pre>

  <script>
    function log(msg) {
      document.getElementById('result').innerHTML += msg + '\n';
    }
    
    async function testInWorker() {
      document.getElementById('result').innerHTML = '<pre>Starting Worker test...\n';
      
      // Get base URL from current page
      const pageBaseUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/') + 1);
      
      // Create inline worker
      const workerCode = `
        (async () => {
          try {
            self.postMessage({ type: 'log', msg: 'Worker started' });
            
            // Set base URL (passed from main thread)
            self.SCIP_BASE_URL = '${pageBaseUrl}';
            self.postMessage({ type: 'log', msg: 'SCIP_BASE_URL set to: ' + self.SCIP_BASE_URL });
            
            // Fetch and execute script (OpenCV pattern)
            self.postMessage({ type: 'log', msg: 'Fetching scip.min.js...' });
            const response = await fetch(self.SCIP_BASE_URL + 'scip.min.js');
            if (!response.ok) throw new Error('Failed to fetch: ' + response.status);
            
            const scriptText = await response.text();
            self.postMessage({ type: 'log', msg: 'Script loaded (' + scriptText.length + ' bytes)' });
            
            // Execute script
            self.postMessage({ type: 'log', msg: 'Executing script...' });
            new Function(scriptText)();
            
            // Check SCIP is available
            if (typeof self.SCIP === 'undefined') {
              throw new Error('SCIP not found in global scope');
            }
            self.postMessage({ type: 'log', msg: 'SCIP object available: ' + Object.keys(self.SCIP).join(', ') });
            
            // Wait for ready (like OpenCV's cv.ready)
            self.postMessage({ type: 'log', msg: 'Waiting for SCIP.ready...' });
            await self.SCIP.ready;
            self.postMessage({ type: 'log', msg: 'SCIP initialized!' });
            
            // Solve a problem
            self.postMessage({ type: 'log', msg: 'Solving LP problem...' });
            const result = await self.SCIP.solve(\`
              Minimize
                obj: 2 x + 3 y
              Subject To
                c1: x + y >= 4
                c2: 2 x + y >= 5
              Bounds
                x >= 0
                y >= 0
              End
            \`);
            
            self.postMessage({ type: 'success', result });
            
          } catch (error) {
            self.postMessage({ type: 'error', msg: error.message, stack: error.stack });
          }
        })();
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      const worker = new Worker(URL.createObjectURL(blob));
      
      worker.onmessage = (e) => {
        const data = e.data;
        if (data.type === 'log') {
          log(data.msg);
        } else if (data.type === 'success') {
          log('<span class="success">SUCCESS!</span>');
          log('Status: ' + data.result.status);
          log('Objective: ' + data.result.objective);
          log('Variables: ' + JSON.stringify(data.result.variables));
          log('</pre>');
          worker.terminate();
        } else if (data.type === 'error') {
          log('<span class="error">ERROR: ' + data.msg + '</span>');
          if (data.stack) log(data.stack);
          log('</pre>');
          worker.terminate();
        }
      };
      
      worker.onerror = (e) => {
        log('<span class="error">Worker error: ' + e.message + '</span></pre>');
      };
    }
  </script>
</body>
</html>
